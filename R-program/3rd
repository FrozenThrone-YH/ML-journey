"""
#목차

#파일 조회 ※함수 list.files()
#파일 열기 및 입력값 받기 
  ※함수 scan("파일명") / readline() / readLines("파일명") / read.table("파일명") 
#CSV파일 
  ※함수 read.csv("파일명")
#SQL쿼리
  ※library "googleVis" "sqldf" / ※함수 : write.csv / read.csv.sql
  ※write.table
#많이 사용되는 기본 함수들 - 22개 
 #aggregate() : 데이터프레임 상대로 주어진 함수 값 구하기
 #실습과제 
 #apply() : 행이나 열을 대상으로 작업을 하기 때문에 matrix에 유용하게 사용 
 #실습과제 
 #lapply(),sapply() : list를 처리 
 #tapply()/mapply() : 데이터셋의 특정요소(factor)를 처리
 #실습과제 
#
#
#
#
#
#
#
#
#
#


----------------------------------------------------------------------------------------------------------------
1교시
setwd("C:\\r_data")

#파일 조회 
list.files()   - 폴더에 있는 파일들이 다 나온다. 
list.files(recursive=T) recursive를 넣으면 폴더 하위디렉토리의 파일까지 조회가 가능하다. 
recursive가 없으면 폴더까지만 조회 그 아래 파일 조회 불가 
list.files(all.files=T) "." ".." ".Rhistory" 숨김파일까지 조회가능하다.

#파일 열기 / 입력값 받기 
> sc1=scan("scan_1.txt")
Read 4 items
> sc1
[1] 111 222 333 444
> sc2=scan("scan_2.txt")
Read 4 items
> sc2
[1] 1 2 3 4

※ 텍스트 파일을 읽어서 배열로 저장했다. 

> sc2=scan("scan_2.txt",what="") ※문자나 실수일 경우에는 옵션 what을 줘야한다.
Read 4 items
> sc2
[1] "1.00" "2.00" "3.00" "4.00"
> sc3=scan("scan_3.txt", what="")
Read 4 items
> sc3
[1] "aaa" "bbb" "ccc" "ddd"

그럼 정수 실수가 모두 섞여 있다면?

> sc4=scan("scan_3.txt", what="")
Read 4 items
> sc5=scan("scan_3.txt")
Error in scan("scan_3.txt") : scan() expected 'a real', got 'aaa'

what이 없다면 에러가 뜬다. 

scan은 사용자로부터 숫자를 입력 받을 수 있다.

> input=scan()
1: 1           ※입력은 콘솔에서 해야한다. 
2: 2
3: 3
4: 
Read 3 items
> input
[1] 1 2 3

> input2=scan(what="") ※문자 입력 
1: a
2: b
3: c
4: 
Read 3 items
> input2
[1] "a" "b" "c"


> input2=scan(what="")
1: aaa bbbb
3: 
Read 2 items

띄어쓰기를 하면 2개로 인식한다. 

그럼 띄어쓰기를 포함한 문자를 인식하려면?

> input3=readline()  ※ readline()이라는 함수를 쓴다. 띄어쓰기를 포함한 한줄을 읽을때
R is very fun!
> input3
[1] "R is very fun!"

경험하지 못한 사람은 어디에 메세지를 넣는지 모른다. 
Readline()안에 문자를 써주면 안내글이 뜬다. 

> input3=readline("R U ok? : ")
R U ok? : no


> input3
[1] "no"


> input5=readLines("scan_4.txt") ※파일을 읽어드려서 배열에 저장한다. L 대문자 주의 
> input5
[1] "aaa"  "bbb"  "111"  "2.34"


> fruits=read.table("fruits.txt") ※파일에서 테이블을 읽어 들일때 read.table("파일명")
> fruits
  V1     V2    V3  V4 헤더가 없는줄 알고 헤더를 붙여 줬다,
1 no   name price qty
2  1  apple   500   5
3  2 banana   200   2
4  3  peach   200   7
5  4  berry    50   9


> fruits2=read.table("fruits.txt",header=T) 헤더가 있다면 옵션으로 헤더=T를 붙여주면 첫째줄을 헤더로 인식 
> fruits2
  no   name price qty
1  1  apple   500   5
2  2 banana   200   2
3  3  peach   200   7
4  4  berry    50   9

※read.table을 통해서 데이터를 불러들여 데이터 프레임 형태로 받는다. 
  조심해야할 것은 헤더가 포함 되었느냐 안되었느냐 안그러면 헤더 자체도 데이터로 읽는다.

read.table의 장점은 주석이나 공백이 있으면 자동으로 제거해준다
※fruits_2.txt에 임의의 공백 설정

> fruits3=read.table("fruits_2.txt")
> fruits3
  V1     V2  V3 V4
1  1  apple 500  6
2  2 banana 200  2
3  3  peach 200  7
4  4  berry  50  9

원래 파일은 아래와 같다. 

# Fruits Test Data - 주석입니다
1   apple   500     6  
2   banana  200     2 
# Null test row - 주석입니다
3   peach   200     7  
4   berry    50     9   


※★중요! 파일 가공할때 공백이 생기는데, read.table을 사용하면 공백을 제거해서 사용가능.

> fruits3=read.table("fruits_2.txt",skip=2) ※스킵 옵션을 건너뛸 줄 수를 말한다. 
> fruits3 
  V1     V2  V3 V4
1  2 banana 200  2
2  3  peach 200  7
3  4  berry  50  9

> fruits3=read.table("fruits_2.txt",nrows=2) ※nrow는 출력할 줄의 갯수를 지정할 수 있다. - 일부만 가져오기 
> fruits3
  V1     V2  V3 V4
1  1  apple 500  6
2  2 banana 200  2


> fruits4=read.table("fruits.txt",header=T, skip=1, nrows=2)
> fruits4
  X1  apple X500 X5  ※데이터가 헤더가 될때는 숫자 앞에 x가 붙는다. 
1  2 banana  200  2
2  3  peach  200  7
> fruits4=read.table("fruits.txt",header=F, skip=1, nrows=2)
> fruits4
  V1     V2  V3 V4
1  1  apple 500  5
2  2 banana 200  2

header가 있지만, skip옵션때문에 헤더가 날라간다. 그 다음 데이터가 헤더가 되버린다. 
헤더가 있는 파일에 skip과 nrow를 써줄때, header = F 해줘야한다.

#csv파일 
메모장으로 열면 구분자가 ','쉼표로 되어 있다.
엑셀로 열면 엑셀 표 처럼 열린다.
예전 2G폰의 연락처는 CSV파일처럼 되어 있었다. 폰 번호 옮길때 CSV파일을 복사 붙여넣기 했으면 됐었다.

> fruits5=read.csv("fruits_3.csv")
> fruits5
  no   name price qty
1  1  apple   500   6
2  2 banana   200   2
3  3  peach   200   7
4  4  berry    50   9

> fruits6=read.csv("fruits_4.csv")
> fruits6
  X1  apple X500 X6
1  2 banana  200  2
2  3  peach  200  7
3  4  berry   50  9

※csv파일은 자동으로 헤더 지정이 되기 때문에 라벨이 없는 경우 csv파일에 수동으로 헤더 지정해줘야한다. 

> fruits6=read.csv("fruits_4.csv", header=F)
> fruits6
  V1     V2  V3 V4
1  1  apple 500  6
2  2 banana 200  2
3  3  peach 200  7
4  4  berry  50  9

아니면 header=F로 옵션을 걸어줘야 라벨이 자동 생성된다. 

> label=c("No","Name","Price","QTY")
> fruits6=read.csv("fruits_4.csv", header=F,col.names=label) ※col.names옵션으로 라벨명 지정 가능
> fruits6
  No   Name Price QTY
1  1  apple   500   6
2  2 banana   200   2
3  3  peach   200   7
4  4  berry    50   9

#SQL쿼리? - 크게 4가지가 있다. 
※빅데이터를 하려면 SQL쿼리문을 반드시 하게 된다. 안하고서는 못한다. 

 1)조회
  : select 컬럼명 from 테이블명 where 조건
    ※모든은 * 아스트릭(?)
 2)삽입
  : insert into 테이블명(테이블에 컬럼들이 있을 것이다.컬럼1,컬럼2,) values(컬럼1에 들어갈 값1, 컬럼2에 들어갈 값2) 
 3)갱신
  : update(테이블명) set 컬럼1 = 값1,컬럼2 = 값2 ... where 조건 
 4)삭제
  : delete from 테이블명 where 조건 
    ※테이블에서 삭제할건데, 어떻게 삭제할것인지?

※★중요! 갱신과 삭제의 조건을 설정하지 않으면, 모든 데이터가 다 갱신 또는 삭제된다. 

install.packages("googleVis") ※빅데이터 분석을 할수 있는 데이터 들이 들어 있다. 
library(googleVis)
install.packages("sqldf")
library(sqldf)

> Fruits
    Fruit Year Location Sales Expenses Profit       Date
1  Apples 2008     West    98       78     20 2008-12-31
2  Apples 2009     West   111       79     32 2009-12-31
3  Apples 2010     West    89       76     13 2010-12-31
4 Oranges 2008     East    96       81     15 2008-12-31
5 Bananas 2008     East    85       76      9 2008-12-31
6 Oranges 2009     East    93       80     13 2009-12-31
7 Bananas 2009     East    94       78     16 2009-12-31
8 Oranges 2010     East    98       91      7 2010-12-31
9 Bananas 2010     East    81       71     10 2010-12-31

구글비스에서 제공하는 Fruits라는 데이터 


write.csv(Fruits,"Fruits_sql.csv",quote=F,row.names=F)

> fruits_2=read.csv.sql("Fruits_sql.csv",sql="select * from file where Year=2008")
> fruits_2
    Fruit Year Location Sales Expenses Profit       Date
1  Apples 2008     West    98       78     20 2008-12-31
2 Oranges 2008     East    96       81     15 2008-12-31
3 Bananas 2008     East    85       76      9 2008-12-31

함수 설명 ※Fruits_sql.csv 에서 year가 2008년인것만 조회해라.

> fruits_2=read.csv.sql("Fruits_sql.csv",sql="select * from file where Year>2008") ※2008년 이후 조회 
> fruits_2
    Fruit Year Location Sales Expenses Profit       Date
1  Apples 2009     West   111       79     32 2009-12-31
2  Apples 2010     West    89       76     13 2010-12-31
3 Oranges 2009     East    93       80     13 2009-12-31
4 Bananas 2009     East    94       78     16 2009-12-31
5 Oranges 2010     East    98       91      7 2010-12-31
6 Bananas 2010     East    81       71     10 2010-12-31

----------------------------------------------------------------------------------------------------------------
2교시

불러오는 함수 비교하기

txt1=read.csv("csv_test.txt")
txt2=readLines("csv_test.txt")
txt3=read.table("csv_test.txt")
txt4=read.table("csv_test.txt",sep=",",header=T)

> txt1
  번호 이름 가격
1    1 사과 1000
2    2   배 2000
3    3   귤 3000
> txt2
[1] "번호,이름,가격" "1,사과,1000"    "2,배,2000"      "3,귤,3000"     
> txt3
              V1
1 번호,이름,가격
2    1,사과,1000
3      2,배,2000
4      3,귤,3000
> txt4
  번호 이름 가격
1    1 사과 1000
2    2   배 2000
3    3   귤 3000


> txt1=readLines("write_test.txt")
> txt1
[1] "이 문장은 write 연습하는 문장인데" "별로 어렵지 않아요"               
[3] "열심히 해주세요"                  
> write(txt1,"write_test2.txt")
> txt2
[1] "번호,이름,가격" "1,사과,1000"    "2,배,2000"      "3,귤,3000"     
> write.table(txt2,"table_test2.txt")


> txt3=tead.csv("csv_test.txt")
Error in tead.csv("csv_test.txt") : could not find function "tead.csv"
> txt3
              V1
1 번호,이름,가격
2    1,사과,1000
3      2,배,2000
4      3,귤,3000
> write.table(txt3,"csv_test2.txt")
> txt4=read.csv("csv_test2.txt")
> txt4
                V1
1 1 번호,이름,가격
2    2 1,사과,1000
3      3 2,배,2000
4      4 3,귤,3000

#많이 사용되는 기본 함수들 
 1) aggregate() : 다양한 함수를 사용하여 계산결과를 출력함
 2) apply() : 다양한 기능이 있어서 나올때마다 봐야한다.
 3) cor() : 상관함수 
 4) cumsum() : 누적합 
 5) cumprom() : 누적곱
 6) diff() : 차이나는 부분을 찾아냄 
 7) length() : 요소갯수를 구해서 출력 
 8) max() : 최대값
 9) min() : 최소값 
 10) mean() : 평균값
 11) median() : 중앙값 - 가운데 값
 12) order() : 각 요소의 원래 위치 ??
 13) prod() : 누적 곱 
 14) range() : 범위값 
 15) rank() : 순위 
 16) rev() : 리버스 - 연순위
 17) sd() : 표준편차
 18) sort() : 정렬
 19) summary() : 요약 통계
 20) sweep() : 일괄적으로 주어진 데이터를 뺌
 21) tapply() : 벡터에서 주어진 함수연산 수행 
 22) var() : 분산값
 
> vec1=c(1,2,3,4,5)
> vec2=c('a','b','c','d','e')
> max(vec1)
[1] 5
> mean(vec1)
[1] 3
> mean(vec2)
[1] NA
Warning message:
In mean.default(vec2) :
  인자가 수치형 또는 논리형이 아니므로 NA를 반환합니다
> min(vec1)
[1] 1
> sd(vec1)
[1] 1.581139
> sum(vec1)
[1] 15
> cumsum(vec1)      ※sum과 cumsum의 차이 
[1]  1  3  6 10 15
> var(vec1)
[1] 2.5

#aggregate() : 데이터프레임 상대로 주어진 함수 값 구하기 
 ※문법 : aggregate(계산될 컬럼~ 기준컬럼, 데이터, 함수)

연도별로 판매한 합계를 나타내라 

> Fruits
    Fruit Year Location Sales Expenses Profit       Date
1  Apples 2008     West    98       78     20 2008-12-31
2  Apples 2009     West   111       79     32 2009-12-31
3  Apples 2010     West    89       76     13 2010-12-31
4 Oranges 2008     East    96       81     15 2008-12-31
5 Bananas 2008     East    85       76      9 2008-12-31
6 Oranges 2009     East    93       80     13 2009-12-31
7 Bananas 2009     East    94       78     16 2009-12-31
8 Oranges 2010     East    98       91      7 2010-12-31
9 Bananas 2010     East    81       71     10 2010-12-31
> aggregate(Sales~Year,Fruits,sum) 연도별로 판매량을 합계한 결과 
  Year Sales
1 2008   279
2 2009   298
3 2010   268


#실습과제  
 - 과일별로 판매된 수량을 합계한 결과 

> aggregate(Sales~Fruit,Fruits,sum)
    Fruit Sales
1  Apples   298
2 Bananas   260
3 Oranges   287

 - 과일별로 가장 많이 판매된 수량 

> aggregate(Sales~Fruit,Fruits,max)
    Fruit Sales
1  Apples   111
2 Bananas    94
3 Oranges    98

 - 과일별 최대판매량에 연도를 추가해서 과일별 연도별 최대판매량

> aggregate(Sales~Fruit+Year,Fruits,max)
    Fruit Year Sales
1  Apples 2008    98
2 Bananas 2008    85
3 Oranges 2008    96
4  Apples 2009   111
5 Bananas 2009    94
6 Oranges 2009    93
7  Apples 2010    89
8 Bananas 2010    81
9 Oranges 2010    98

#apply() : 행이나 열을 대상으로 작업을 하기 때문에 matrix에 유용하게 사용 
 ※문법 : apply(대상, 행/열, 적용함수) 
 
> mat1=matrix(c(1,2,3,
+               4,5,6),nrow=2) ※ 열우선 법칙 
> mat1
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

> mat1=matrix(c(1,2,3,
+               4,5,6),nrow=2,byrow=T) ※ 행우선으로 하려면 byrow 옵션 걸어줘야함 
> mat1
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6

> apply(mat1,1,sum) mat1에서 각행에 대한 합계 
[1]  6 15
> apply(mat1,2,sum) mat1에서 각열에 대한 합계  ※1은 행, 2는 열 
[1] 5 7 9

#실습과제 
2열과 3열의 최대값 
> apply(mat1[,c(2,3)],2,max)
[1] 5 6

----------------------------------------------------------------------------------------------------------------
3교시

#lapply(),sapply() : list를 처리 
 ※문법 : lapply/sapply(대상,적용함수)

> list1=list(Fruits$Sales)
> list1
[[1]]
[1]  98 111  89  96  85  93  94  98  81

> list2=list(Fruits$Profit)
> list2
[[1]]
[1] 20 32 13 15  9 13 16  7 10

> lapply(c(list1,list2),max)
[[1]]
[1] 111

[[2]]
[1] 32

> sapply(c(list1,list2),max)
[1] 111  32 

※ lapply와 sapply는 출력해주는 형태가 다르다. sapply는 한줄에 다 나온다. 

> lapply(Fruits[,c(4,5)],max)
$Sales
[1] 111

$Expenses
[1] 91

> sapply(Fruits[,c(4,5)],max)
   Sales Expenses 
     111       91 

#tapply()/mapply() : 데이터셋의 특정요소(factor)를 처리
 1) tapply() : 데이터셋의 특정요소(factor)를 처리
 2) mapply() : 벡터나 리스트를 테이터프레임처럼 처리 
 ※문법 : tapply(출력값, 기준컬럼,적용함수)
          mapply(함수, 벡터1,벡터2, ......)

> Fruits
    Fruit Year Location Sales Expenses Profit       Date
1  Apples 2008     West    98       78     20 2008-12-31
2  Apples 2009     West   111       79     32 2009-12-31
3  Apples 2010     West    89       76     13 2010-12-31
4 Oranges 2008     East    96       81     15 2008-12-31
5 Bananas 2008     East    85       76      9 2008-12-31
6 Oranges 2009     East    93       80     13 2009-12-31
7 Bananas 2009     East    94       78     16 2009-12-31
8 Oranges 2010     East    98       91      7 2010-12-31
9 Bananas 2010     East    81       71     10 2010-12-31

> attach(Fruits) ※★중요 Fruits라는 데이터프레임을 그대로 쓰려면 attach 함수를 써줘야한다.!

> tapply(Sales,Fruit,sum) ※과일별로 합계판매량
 Apples Bananas Oranges 
    298     260     287 

> tapply(Sales,Year,sum) ※연도별로 합계판매량
2008 2009 2010 
 279  298  268  

> v1=c(1,2,3,4,5)
> v2=c(10,20,30,40,50)
> v3=c(100,200,300,400,500)
> mapply(sum, v1,v2,v3)
[1] 111 222 333 444 555

★중요! mapply를 쓰려면 벡터의 요소갯수가 같아야 한다. 
> v1=c(1,2,3,4,5)
> v2=c(10,20,30,40)
> v3=c(100,200,300,400,500)
> mapply(sum, v1,v2,v3)
[1] 111 222 333 444 515
Warning message:
In mapply(sum, v1, v2, v3) :
  longer argument not a multiple of length of shorter

다르면 계산은 되는데, 워닝이 뜬다. 그리고 v2는 순환한다. 

#실습과제 
1)data1.csv파일을 불러와 data1에 저장하고, 년도별 합계값과 
 연령대별 합계를 구하라. 
> data1=read.table("data1.csv",sep=",",header=T)
> data1
    연령별 X2000년 X2001년 X2002년 X2003년 X2004년 X2005년 X2006년 X2007년
1     20대     7.5     7.4     6.6     7.7     7.9     7.7     7.7     7.1
2     30대     3.6     3.2     2.9     3.0     3.1     3.3     3.0     3.2
3     40대     3.5     3.0     2.0     2.2     2.3     2.6     2.3     2.0
4     50대     3.3     2.8     2.0     2.2     2.3     2.5     2.2     2.1
5 60세이상     1.5     1.2     1.1     1.0     1.2     1.3     1.4     1.4
  X2008년 X2009년 X2010년 X2011년 X2012년 X2013년
1     7.0     7.9     7.8     7.4     7.5     7.9
2     3.1     3.6     3.5     3.4     3.0     3.0
3     2.1     2.5     2.5     2.1     2.1     2.0
4     2.0     2.5     2.4     2.1     2.1     1.9
5     1.2     1.6     3.0     2.7     2.5     1.9
> apply(data1[,c(2:15)],2,sum)
X2000년 X2001년 X2002년 X2003년 X2004년 X2005년 X2006년 X2007년 X2008년 
   19.4    17.6    14.6    16.1    16.8    17.4    16.6    15.8    15.4 
X2009년 X2010년 X2011년 X2012년 X2013년 
   18.1    19.2    17.7    17.2    16.7 

> apply(data1[c(1:5),c(2:15)],1,sum)
    1     2     3     4     5 
105.1  44.9  33.2  32.4  23.0 
> apply(data1[,c(2:15)],1,sum)
[1] 105.1  44.9  33.2  32.4  23.0

#강사님 풀이 : 같음 

2) 1~4호선 승하차승객수.csv 파일을 불러와서 data2에 저장한 후
   노선별 승차인원수 합계 
   노선별 하차인원 수 합계 
   노선별 상관없이 승차 하차 인원수 합계 
   노선 번호별 승하차 인원수 합계  
   노선 번호별 승차 인원수 합계 
   노선 번호별 하차 인원수 합계 
   ※ stringasfactors=F를 넣어줘야 문자가 factor로 변하지 않는다. 


data2=read.csv("1-4호선승하차승객수.csv",header=T,stringsAsFactors=F)
data2
attach(data2)
> tapply(승차,노선번호,sum)
  line_1   line_2   line_3   line_4 
 9666934 47393885 16484269 19851059 

> tapply(하차,노선번호,sum)
  line_1   line_2   line_3   line_4 
 9430846 47983161 16555337 20022066 

> sapply(data2[c(3,4)],sum)
    승차     하차 
93396147 93991410 

> aggregate(승차+하차~노선번호,data2,sum)
  노선번호 승차 + 하차
1   line_1    19097780
2   line_2    95377046
3   line_3    33039606
4   line_4    39873125

> aggregate(승차~노선번호,data2,sum)
  노선번호     승차
1   line_1  9666934
2   line_2 47393885
3   line_3 16484269
4   line_4 19851059

> aggregate(하차~노선번호,data2,sum)
  노선번호     하차
1   line_1  9430846
2   line_2 47983161
3   line_3 16555337
4   line_4 20022066

----------------------------------------------------------------------------------------------------------------
4교시


"""
