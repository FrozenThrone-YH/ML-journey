"""
#목차

#파일 조회 ※함수 list.files()
#파일 열기 및 입력값 받기 
  ※함수 scan("파일명") / readline() / readLines("파일명") / read.table("파일명") 
#CSV파일 
  ※함수 read.csv("파일명")
#SQL쿼리
  ※library "googleVis" "sqldf" / ※함수 : write.csv / read.csv.sql
  ※write.table
#많이 사용되는 기본 함수들 - 22개 
 #aggregate() : 데이터프레임 상대로 주어진 함수 값 구하기
 #실습과제 
 #apply() : 
#
#
#
#
#
#
#
#
#
#


----------------------------------------------------------------------------------------------------------------
1교시
setwd("C:\\r_data")

#파일 조회 
list.files()   - 폴더에 있는 파일들이 다 나온다. 
list.files(recursive=T) recursive를 넣으면 폴더 하위디렉토리의 파일까지 조회가 가능하다. 
recursive가 없으면 폴더까지만 조회 그 아래 파일 조회 불가 
list.files(all.files=T) "." ".." ".Rhistory" 숨김파일까지 조회가능하다.

#파일 열기 / 입력값 받기 
> sc1=scan("scan_1.txt")
Read 4 items
> sc1
[1] 111 222 333 444
> sc2=scan("scan_2.txt")
Read 4 items
> sc2
[1] 1 2 3 4

※ 텍스트 파일을 읽어서 배열로 저장했다. 

> sc2=scan("scan_2.txt",what="") ※문자나 실수일 경우에는 옵션 what을 줘야한다.
Read 4 items
> sc2
[1] "1.00" "2.00" "3.00" "4.00"
> sc3=scan("scan_3.txt", what="")
Read 4 items
> sc3
[1] "aaa" "bbb" "ccc" "ddd"

그럼 정수 실수가 모두 섞여 있다면?

> sc4=scan("scan_3.txt", what="")
Read 4 items
> sc5=scan("scan_3.txt")
Error in scan("scan_3.txt") : scan() expected 'a real', got 'aaa'

what이 없다면 에러가 뜬다. 

scan은 사용자로부터 숫자를 입력 받을 수 있다.

> input=scan()
1: 1           ※입력은 콘솔에서 해야한다. 
2: 2
3: 3
4: 
Read 3 items
> input
[1] 1 2 3

> input2=scan(what="") ※문자 입력 
1: a
2: b
3: c
4: 
Read 3 items
> input2
[1] "a" "b" "c"


> input2=scan(what="")
1: aaa bbbb
3: 
Read 2 items

띄어쓰기를 하면 2개로 인식한다. 

그럼 띄어쓰기를 포함한 문자를 인식하려면?

> input3=readline()  ※ readline()이라는 함수를 쓴다. 띄어쓰기를 포함한 한줄을 읽을때
R is very fun!
> input3
[1] "R is very fun!"

경험하지 못한 사람은 어디에 메세지를 넣는지 모른다. 
Readline()안에 문자를 써주면 안내글이 뜬다. 

> input3=readline("R U ok? : ")
R U ok? : no


> input3
[1] "no"


> input5=readLines("scan_4.txt") ※파일을 읽어드려서 배열에 저장한다. L 대문자 주의 
> input5
[1] "aaa"  "bbb"  "111"  "2.34"


> fruits=read.table("fruits.txt") ※파일에서 테이블을 읽어 들일때 read.table("파일명")
> fruits
  V1     V2    V3  V4 헤더가 없는줄 알고 헤더를 붙여 줬다,
1 no   name price qty
2  1  apple   500   5
3  2 banana   200   2
4  3  peach   200   7
5  4  berry    50   9


> fruits2=read.table("fruits.txt",header=T) 헤더가 있다면 옵션으로 헤더=T를 붙여주면 첫째줄을 헤더로 인식 
> fruits2
  no   name price qty
1  1  apple   500   5
2  2 banana   200   2
3  3  peach   200   7
4  4  berry    50   9

※read.table을 통해서 데이터를 불러들여 데이터 프레임 형태로 받는다. 
  조심해야할 것은 헤더가 포함 되었느냐 안되었느냐 안그러면 헤더 자체도 데이터로 읽는다.

read.table의 장점은 주석이나 공백이 있으면 자동으로 제거해준다
※fruits_2.txt에 임의의 공백 설정

> fruits3=read.table("fruits_2.txt")
> fruits3
  V1     V2  V3 V4
1  1  apple 500  6
2  2 banana 200  2
3  3  peach 200  7
4  4  berry  50  9

원래 파일은 아래와 같다. 

# Fruits Test Data - 주석입니다
1   apple   500     6  
2   banana  200     2 
# Null test row - 주석입니다
3   peach   200     7  
4   berry    50     9   


※★중요! 파일 가공할때 공백이 생기는데, read.table을 사용하면 공백을 제거해서 사용가능.

> fruits3=read.table("fruits_2.txt",skip=2) ※스킵 옵션을 건너뛸 줄 수를 말한다. 
> fruits3 
  V1     V2  V3 V4
1  2 banana 200  2
2  3  peach 200  7
3  4  berry  50  9

> fruits3=read.table("fruits_2.txt",nrows=2) ※nrow는 출력할 줄의 갯수를 지정할 수 있다. - 일부만 가져오기 
> fruits3
  V1     V2  V3 V4
1  1  apple 500  6
2  2 banana 200  2


> fruits4=read.table("fruits.txt",header=T, skip=1, nrows=2)
> fruits4
  X1  apple X500 X5  ※데이터가 헤더가 될때는 숫자 앞에 x가 붙는다. 
1  2 banana  200  2
2  3  peach  200  7
> fruits4=read.table("fruits.txt",header=F, skip=1, nrows=2)
> fruits4
  V1     V2  V3 V4
1  1  apple 500  5
2  2 banana 200  2

header가 있지만, skip옵션때문에 헤더가 날라간다. 그 다음 데이터가 헤더가 되버린다. 
헤더가 있는 파일에 skip과 nrow를 써줄때, header = F 해줘야한다.

#csv파일 
메모장으로 열면 구분자가 ','쉼표로 되어 있다.
엑셀로 열면 엑셀 표 처럼 열린다.
예전 2G폰의 연락처는 CSV파일처럼 되어 있었다. 폰 번호 옮길때 CSV파일을 복사 붙여넣기 했으면 됐었다.

> fruits5=read.csv("fruits_3.csv")
> fruits5
  no   name price qty
1  1  apple   500   6
2  2 banana   200   2
3  3  peach   200   7
4  4  berry    50   9

> fruits6=read.csv("fruits_4.csv")
> fruits6
  X1  apple X500 X6
1  2 banana  200  2
2  3  peach  200  7
3  4  berry   50  9

※csv파일은 자동으로 헤더 지정이 되기 때문에 라벨이 없는 경우 csv파일에 수동으로 헤더 지정해줘야한다. 

> fruits6=read.csv("fruits_4.csv", header=F)
> fruits6
  V1     V2  V3 V4
1  1  apple 500  6
2  2 banana 200  2
3  3  peach 200  7
4  4  berry  50  9

아니면 header=F로 옵션을 걸어줘야 라벨이 자동 생성된다. 

> label=c("No","Name","Price","QTY")
> fruits6=read.csv("fruits_4.csv", header=F,col.names=label) ※col.names옵션으로 라벨명 지정 가능
> fruits6
  No   Name Price QTY
1  1  apple   500   6
2  2 banana   200   2
3  3  peach   200   7
4  4  berry    50   9

#SQL쿼리? - 크게 4가지가 있다. 
※빅데이터를 하려면 SQL쿼리문을 반드시 하게 된다. 안하고서는 못한다. 

 1)조회
  : select 컬럼명 from 테이블명 where 조건
    ※모든은 * 아스트릭(?)
 2)삽입
  : insert into 테이블명(테이블에 컬럼들이 있을 것이다.컬럼1,컬럼2,) values(컬럼1에 들어갈 값1, 컬럼2에 들어갈 값2) 
 3)갱신
  : update(테이블명) set 컬럼1 = 값1,컬럼2 = 값2 ... where 조건 
 4)삭제
  : delete from 테이블명 where 조건 
    ※테이블에서 삭제할건데, 어떻게 삭제할것인지?

※★중요! 갱신과 삭제의 조건을 설정하지 않으면, 모든 데이터가 다 갱신 또는 삭제된다. 

install.packages("googleVis") ※빅데이터 분석을 할수 있는 데이터 들이 들어 있다. 
library(googleVis)
install.packages("sqldf")
library(sqldf)

> Fruits
    Fruit Year Location Sales Expenses Profit       Date
1  Apples 2008     West    98       78     20 2008-12-31
2  Apples 2009     West   111       79     32 2009-12-31
3  Apples 2010     West    89       76     13 2010-12-31
4 Oranges 2008     East    96       81     15 2008-12-31
5 Bananas 2008     East    85       76      9 2008-12-31
6 Oranges 2009     East    93       80     13 2009-12-31
7 Bananas 2009     East    94       78     16 2009-12-31
8 Oranges 2010     East    98       91      7 2010-12-31
9 Bananas 2010     East    81       71     10 2010-12-31

구글비스에서 제공하는 Fruits라는 데이터 


write.csv(Fruits,"Fruits_sql.csv",quote=F,row.names=F)

> fruits_2=read.csv.sql("Fruits_sql.csv",sql="select * from file where Year=2008")
> fruits_2
    Fruit Year Location Sales Expenses Profit       Date
1  Apples 2008     West    98       78     20 2008-12-31
2 Oranges 2008     East    96       81     15 2008-12-31
3 Bananas 2008     East    85       76      9 2008-12-31

함수 설명 ※Fruits_sql.csv 에서 year가 2008년인것만 조회해라.

> fruits_2=read.csv.sql("Fruits_sql.csv",sql="select * from file where Year>2008") ※2008년 이후 조회 
> fruits_2
    Fruit Year Location Sales Expenses Profit       Date
1  Apples 2009     West   111       79     32 2009-12-31
2  Apples 2010     West    89       76     13 2010-12-31
3 Oranges 2009     East    93       80     13 2009-12-31
4 Bananas 2009     East    94       78     16 2009-12-31
5 Oranges 2010     East    98       91      7 2010-12-31
6 Bananas 2010     East    81       71     10 2010-12-31

----------------------------------------------------------------------------------------------------------------
2교시

불러오는 함수 비교하기

txt1=read.csv("csv_test.txt")
txt2=readLines("csv_test.txt")
txt3=read.table("csv_test.txt")
txt4=read.table("csv_test.txt",sep=",",header=T)

> txt1
  번호 이름 가격
1    1 사과 1000
2    2   배 2000
3    3   귤 3000
> txt2
[1] "번호,이름,가격" "1,사과,1000"    "2,배,2000"      "3,귤,3000"     
> txt3
              V1
1 번호,이름,가격
2    1,사과,1000
3      2,배,2000
4      3,귤,3000
> txt4
  번호 이름 가격
1    1 사과 1000
2    2   배 2000
3    3   귤 3000


> txt1=readLines("write_test.txt")
> txt1
[1] "이 문장은 write 연습하는 문장인데" "별로 어렵지 않아요"               
[3] "열심히 해주세요"                  
> write(txt1,"write_test2.txt")
> txt2
[1] "번호,이름,가격" "1,사과,1000"    "2,배,2000"      "3,귤,3000"     
> write.table(txt2,"table_test2.txt")


> txt3=tead.csv("csv_test.txt")
Error in tead.csv("csv_test.txt") : could not find function "tead.csv"
> txt3
              V1
1 번호,이름,가격
2    1,사과,1000
3      2,배,2000
4      3,귤,3000
> write.table(txt3,"csv_test2.txt")
> txt4=read.csv("csv_test2.txt")
> txt4
                V1
1 1 번호,이름,가격
2    2 1,사과,1000
3      3 2,배,2000
4      4 3,귤,3000

#많이 사용되는 기본 함수들 
 1) aggregate() : 다양한 함수를 사용하여 계산결과를 출력함
 2) apply() : 다양한 기능이 있어서 나올때마다 봐야한다.
 3) cor() : 상관함수 
 4) cumsum() : 누적합 
 5) cumprom() : 누적곱
 6) diff() : 차이나는 부분을 찾아냄 
 7) length() : 요소갯수를 구해서 출력 
 8) max() : 최대값
 9) min() : 최소값 
 10) mean() : 평균값
 11) median() : 중앙값 - 가운데 값
 12) order() : 각 요소의 원래 위치 ??
 13) prod() : 누적 곱 
 14) range() : 범위값 
 15) rank() : 순위 
 16) rev() : 리버스 - 연순위
 17) sd() : 표준편차
 18) sort() : 정렬
 19) summary() : 요약 통계
 20) sweep() : 일괄적으로 주어진 데이터를 뺌
 21) tapply() : 벡터에서 주어진 함수연산 수행 
 22) var() : 분산값
 
> vec1=c(1,2,3,4,5)
> vec2=c('a','b','c','d','e')
> max(vec1)
[1] 5
> mean(vec1)
[1] 3
> mean(vec2)
[1] NA
Warning message:
In mean.default(vec2) :
  인자가 수치형 또는 논리형이 아니므로 NA를 반환합니다
> min(vec1)
[1] 1
> sd(vec1)
[1] 1.581139
> sum(vec1)
[1] 15
> cumsum(vec1)      ※sum과 cumsum의 차이 
[1]  1  3  6 10 15
> var(vec1)
[1] 2.5

#aggregate() : 데이터프레임 상대로 주어진 함수 값 구하기 
 ※문법 : aggregate(계산될 컬럼~ 기준컬럼, 데이터, 함수)

연도별로 판매한 합계를 나타내라 

> Fruits
    Fruit Year Location Sales Expenses Profit       Date
1  Apples 2008     West    98       78     20 2008-12-31
2  Apples 2009     West   111       79     32 2009-12-31
3  Apples 2010     West    89       76     13 2010-12-31
4 Oranges 2008     East    96       81     15 2008-12-31
5 Bananas 2008     East    85       76      9 2008-12-31
6 Oranges 2009     East    93       80     13 2009-12-31
7 Bananas 2009     East    94       78     16 2009-12-31
8 Oranges 2010     East    98       91      7 2010-12-31
9 Bananas 2010     East    81       71     10 2010-12-31
> aggregate(Sales~Year,Fruits,sum) 연도별로 판매량을 합계한 결과 
  Year Sales
1 2008   279
2 2009   298
3 2010   268


#실습과제  
 - 과일별로 판매된 수량을 합계한 결과 

> aggregate(Sales~Fruit,Fruits,sum)
    Fruit Sales
1  Apples   298
2 Bananas   260
3 Oranges   287

 - 과일별로 가장 많이 판매된 수량 

> aggregate(Sales~Fruit,Fruits,max)
    Fruit Sales
1  Apples   111
2 Bananas    94
3 Oranges    98

 - 과일별 최대판매량에 연도를 추가해서 과일별 연도별 최대판매량

> aggregate(Sales~Fruit+Year,Fruits,max)
    Fruit Year Sales
1  Apples 2008    98
2 Bananas 2008    85
3 Oranges 2008    96
4  Apples 2009   111
5 Bananas 2009    94
6 Oranges 2009    93
7  Apples 2010    89
8 Bananas 2010    81
9 Oranges 2010    98

#apply() : 행이나 열을 대상으로 작업을 하기 때문에 matrix에 유용하게 사용 
 ※문법 : apply(대상, 행/열, 적용함수) 
 
> mat1=matrix(c(1,2,3,
+               4,5,6),nrow=2) ※ 열우선 법칙 
> mat1
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

> mat1=matrix(c(1,2,3,
+               4,5,6),nrow=2,byrow=T) ※ 행우선으로 하려면 byrow 옵션 걸어줘야함 
> mat1
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6

> apply(mat1,1,sum) mat1에서 각행에 대한 합계 
[1]  6 15
> apply(mat1,2,sum) mat1에서 각열에 대한 합계  ※1은 행, 2는 열 
[1] 5 7 9

#실습과제 
2열과 3열의 최대값 
> apply(mat1[,c(2,3)],2,max)
[1] 5 6




"""
