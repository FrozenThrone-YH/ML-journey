#191020
------------------------------------------------------------------------------
1교시

setwd("C:/r_data")
getwd()
해놓고 시작 


#변수 

var1="aaa"
위 변수를 오른쪽상단 환경에서 보면
values 로 해서

> var1="aaa"
var1이라는 변수에 "aaa" 문자가 지정된 걸 확인할수 있다.  
> var2=1234
var2라는 변수에 1234 숫자가 지정된 걸 확인할 수 있다.

> var3=c("a","b","c")  ※ c()는 컴바인 함수 - 
컴바인 함수, 환경에
var3에 chr[1:3] "a" "b" "c" 첫번째 행에 문자열 3개가 들어가 있다.


> var4=c(1,2,3,4)
> var4
[1] 1 2 3 4
환경에서 var4변수에 num[1:4] 1 2 3 4 숫자 4개가 들어 있다. 

> 111->a->b->c
> a
[1] 111
> b
[1] 111
> c
[1] 111
연속할당, 111을 a/b/c에 할당 
※왼쪽에서 오른쪽으로 값을 입력하는 것은 추천하지 않는다. 
기본적으로 프로그래밍언어에서는 대입연산자 기준으로 오른쪽으로 값,수식,변수,상수
왼쪽에는 변수,상수
※대입연산자 = , <-


> a<-b<-c<-222
> a
[1] 222
> b
[1] 222
> c
[1] 222

이렇게 연속적으로 할당 가능

> str1="Hi 안녕"
> str1
[1] "Hi 안녕" 
문자열 저장도 가능 

컴바인 함수를 이용하여 문자와 숫자를 같이 저장 가능
> ch1=c(1,2,3,"a","b")
> ch1
[1] "1" "2" "3" "a" "b"

> class(ch1)
[1] "character"

하지만 자료형은 문자형이다.

팩터와 문자가 만나면? factor형이다. 

#변수 설정시 주의사항
1) 대소문자 구분필요
2) 영어,숫자,모두 쓸수 있지만 시작은 반드시 문자
3) 예약어 사용 불가 
  ※예약어 - 프로그래밍을 하기 위해 미리 정해져 있는 명령어 EX) NA, NULL, FUNCTION,IF,ELSE,TRUE,FALSE 등

> num1=1
> num2=2
> num1+num2
[1] 3

#변수에 연속적인 값 대입 (seq함수)

> seq1=1:5
> seq1
[1] 1 2 3 4 5  ※자료형은 num이 아닌 int?

> seq2='a':'b'
Error in "a":"b" : NA/NaN argument
In addition: Warning messages:
1: NAs introduced by coercion 
2: NAs introduced by coercion 

문자열은 시퀀스가 안된다. 

> date1=seq(as.Date("2019-10-01"), as.Date("2019-10-31"),1)
> date1
 [1] "2019-10-01" "2019-10-02" "2019-10-03" "2019-10-04" "2019-10-05"
 [6] "2019-10-06" "2019-10-07" "2019-10-08" "2019-10-09" "2019-10-10"
[11] "2019-10-11" "2019-10-12" "2019-10-13" "2019-10-14" "2019-10-15"
[16] "2019-10-16" "2019-10-17" "2019-10-18" "2019-10-19" "2019-10-20"
[21] "2019-10-21" "2019-10-22" "2019-10-23" "2019-10-24" "2019-10-25"
[26] "2019-10-26" "2019-10-27" "2019-10-28" "2019-10-29" "2019-10-30"
[31] "2019-10-31"


 > date2=seq(as.Date("2019-01-01"), as.Date("2019-12-31"),"month")
> date2
 [1] "2019-01-01" "2019-02-01" "2019-03-01" "2019-04-01" "2019-05-01"
 [6] "2019-06-01" "2019-07-01" "2019-08-01" "2019-09-01" "2019-10-01"
[11] "2019-11-01" "2019-12-01"

> date3=seq(as.Date("2019-01-01"), as.Date("2019-12-31"),by="month")
> date3
 [1] "2019-01-01" "2019-02-01" "2019-03-01" "2019-04-01" "2019-05-01"
 [6] "2019-06-01" "2019-07-01" "2019-08-01" "2019-09-01" "2019-10-01"
[11] "2019-11-01" "2019-12-01"
> date4=seq(from=as.Date("2019-01-01"), to=as.Date("2019-12-31"),by="month")
> date4
 [1] "2019-01-01" "2019-02-01" "2019-03-01" "2019-04-01" "2019-05-01"
 [6] "2019-06-01" "2019-07-01" "2019-08-01" "2019-09-01" "2019-10-01"
[11] "2019-11-01" "2019-12-01"

date2,date3,date4는 결과가 같다. by, from to 를 굳이 안써도 

#함수 - objects() : 그동안 사용한 변수들이 조회된다. 
> objects()
 [1] "a"     "b"     "c"     "ch1"   "CH2"   "date1" "date2" "date3" "date4"
[10] "num1"  "num2"  "seq1"  "str1"  "var1"  "var2"  "var3"  "var4" 
> objects(all.names=T)
 [1] ".Random.seed" "a"            "b"            "c"           
 [5] "ch1"          "CH2"          "date1"        "date2"       
 [9] "date3"        "date4"        "num1"         "num2"        
[13] "seq1"         "str1"         "var1"         "var2"        
[17] "var3"         "var4"     

all.names=t로 하면 .(dot)로 표현된 숨겨진 변수도 나타내진다. 


#함수 - rm() : 변수 삭제 
> rm(str1)
> objects()
 [1] "a"     "b"     "c"     "ch1"   "CH2"   "date1" "date2" "date3" "date4"
[10] "num1"  "num2"  "seq1"  "var1"  "var2"  "var3"  "var4" 


> rm(list=ls())
> objects()
character(0)

list=ls()로 하면 다 지워진다. 

#앞으로 할 것 예고 

> x=c(9,15,21,7) #영업1/영업2/영업3/영업4 팀의 실적
> x
[1]  9 15 21  7
> pie(x)

plot에 원형함수가 뜬다. 

> x=c(9,15,21,7) #영업1/영업2/영업3/영업4 팀의 실적
> x
[1]  9 15 21  7
> label=c("영업1","영업2","영업3","영업4")
> pie(x,labels=label,main="팀별 영업 실적")

이것이 시각화이다. 

barplot(x, names.arg=label, main="팀별 영업 실적")
> 

barplot(x, names.arg=label, main="팀별 영업 실적",col=rainbow(length(x)))
> 
색깔별로 그래프를 나타낼수 있다. 

install.packages("wordcloud")
install.packages("RColorBrewer") #패키지 깔기 
library(wordcloud)
library(RColorBrewer) #패키지 붙이기

pal=brewer.pal(8,"Dark2")
> x=c("국민","한국","민족")
> y=c(10,7,4) #x의 빈도수수
> wordcloud(x,y,colors=pal)
> 
plots에서 빈도수를 볼 수 있다. 

#데이터 처리 객체(6가지)
 #동일 데이터 타입 객체 : 스칼라, 벡터, matrix, array
  1) 스칼라 : 단일 데이터 처리  [1]
  2) 벡터 : 1차원 배열 (스칼라를 여러개 합친것) 1행짜리 [1,2,3,4,5]
  3) matrix : 2차원 배열 (벡터를 여러개 합친것) 행과 열이 여러개 [1,2,3,4,5
                                                                  6,7,8,9,10]
  4) array : 3차원 배열 (메트릭스를 여러개 합친것) - 큐브 형태 
             [1,2,3  [7,8,9     [13,14,15
              4,5,6]  10,11,12]  16,17,18]
 
 #다른 데이터 타입 객체 : list, dataframe
  1) list : 벡터와 비슷 (python의 dictionaty - 키와 값 형태로 저장이 된다.) 
  2) dataframe : 컬럼명이 있고, 컬럼 밑에 값들이 존재한다. 엑셀의 표나 db의 TABLE 형태 (db의 컬럼처럼 라벨이 있음)
                 학번, 학과, 성적, ---
                   1, 컴공,   A,
                   2. 기계.   B 

  
#빅데이터를 하려면?
  - 데이터베이스를 하고 나서 넘어와야한다.? - 이데이터들이 어떻게 만들어져서 데이터베이스라는 곳에 저장이 되고,
    어떻게 가져오는지 알고 나서R/python을 해야한다. 
    DB에 대한 개념이 있어야 한다. 

> c(1,2,3,4,5)
[1] 1 2 3 4 5
※벡터 : 1차원 배열
  1) c()함수로 작성
  2) 인덱스는 1부터 시작 (python은 0부터)
  3) 하나의 자료형만 사용
  4) 결측값은 'NA' 사용 - 시험 데이터에서 결측치가 굉장히 많이 나온다. 
  5) null은 어떤 형식도 취하지 않는 특별한 객체다. 

#특정위치 값 제어 

> vec1=1:5
> vec1
[1] 1 2 3 4 5
> vec1[3]
[1] 3

> vec1[-3] ※ 3번째것을 제외하고 가져와라 
[1] 1 2 4 5

> vec1[1:(length(vec1))]  ※길이를 모를때 length 함수를 쓴다. 
[1] 1 2 3 4 5

> vec1[1:(length(vec1)-2)] ※전체길이에서 2를 뺀 숫자를 가져오기 
[1] 1 2 3

> vec1[-1:-3] ※1번부터 3번까지 제외하고 가져와라 
[1] 4 5

> vec1[2]=6 ※ 값 치환 = 2번째것을 6으로 변경 
> vec1
[1] 1 6 3 4 5

> vec2=c(1,7)
> vec2
[1] 1 7

> vec2=c(vec1,7) ※vec1 맨 뒤에 7 추가 
> vec2
[1] 1 6 3 4 5 7

> vec2[9]=9 ※ 9번째에 9번 넣기 7,8번에는 NA가 들어간다. 
                특정위치에 넣을 수 있다. 건너 뛰고 
> vec2
[1]  1  6  3  4  5  7 NA NA  9

> append(vec2,10,after=3)  vec2에 10을 넣을 건데, 3번째 뒤에 넣어라 
 [1]  1  6  3 10  4  5  7 NA NA  9

> append(vec2,c(10,11),after=3) vec2에 10,11을 넣을 건데, 3번째 뒤에 넣어라,
 [1]  1  6  3 10 11  4  5  7 NA NA  9   ※ 4번째가 치환되지 않고 뒤로 밀린다. 
※ 10과 11의 간격이 좁다. 

c(10,11)과 같은 값이 나오나?
> append(vec3,10,after=3)
[1]  1  2  3 10  4  5
> append(vec3,11,after=3)
[1]  1  2  3 11  4  5       -> 앞에 것과 다르다. 왜냐면 변수에 저장이 안되었기 때문에 

> v3=append(vec2,10,after=3)
> v4=append(v3,11,after=3)
> v4
 [1]  1  6  3 11 10  4  5  7 NA NA  9

> v4=append(v4,12,after=0)
> v4
 [1] 12  1  6  3 11 10  4  5  7 NA NA  9

#r에서 1번째가 1인 이유 
1번째가 1인 이유, 1번째에 값을 넣기 위해서! after=0으로 하면 제일 앞에다가 자료를 넣을 수 있다.
R에서 1번째가 1인 이유 

※배열에서 -값이 나올 수 없다? - 자료구조 강의에서 배울 수 있다. 

------------------------------------------------------------------------------
2교시
