"""
1. Numpy를 사용하는 이유 
  1) 성능 : 파이썬 리스트보다 빠름
  2) 메모리 사이즈 : 파이썬 리스트보다 적은 메모리 사용
  3) 빌트인 함수 : 선형대수, 통계관련 여러 함수 내장 
     ※ 쉽게 연산 적용
  
2. ndarray : C언어로 구성되어 있음
  1) numpy에서 사용되는 다차원 리스트를 표현할 때 사용되는 데이터 타입 
  2) ndarray 연속된 메모리 Vectorization 사용 ※Vectorization 개념이 굉장히 중요 1부터 100까지 ndarray를 한덩어리로 생각한다. 
     python list - 연속되지 않은 메모리 명시적인 loop사용 
     
3. numpy 설치 확인 
  - Anaconda navigator - Environments - 솔팅을 all로 한다음 numpy 검색 체크 / matplotlib 검색 체크 
  
4. ndarray 데이터 생성하기 (numpy 모듈 함수 이용) 
  
"""

#실습코드1
import numpy as np
import matplotlib.pylpot as plt

x = np.array([1,2,3])
y = np.array([2,4,6])

plt.plot(x,y)
# 그래프가 결과로 도출 

#np.array 함수로 생성하기 

x=np.array([1,2,3,4])
print(x)

y=np.array([[2,3,4],[1,2,5]]) #2차원 행렬 [[]] 괄호 2개씩 
print(y)

"""
결과물
[1 2 3 4]
[[2 3 4]
 [1 2 5]]
"""

print(type(y)) # <class 'numpy.ndarray'>

np.arange(10) # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
np.arange(1,10) #시작 숫자 설정 #결과 ; array([1, 2, 3, 4, 5, 6, 7, 8, 9])
np.arange(1,10, 2) #단계 설정 #결과 : array([1, 3, 5, 7, 9])
np.arange(5,101,5) #결과 : array([  5,  10,  15,  20,  25,  30,  35,  40,  45,  50,  55,  60,  65,
                   #70,  75,  80,  85,  90,  95, 100])
                   
np.ones((4,5)) #모든 원소가 1, 성분을 튜플을 이용해서 나타낸다. 4행 5열
"""
결과물
array([[1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.]])
"""

np.ones((2,4,5)) #3차원 
"""
array([[[1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.]],

       [[1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.]]])"""
        
np.zeros((2,3,8))
"""
array([[[0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0.]],

       [[0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0., 0., 0., 0.]]])
"""

np.empty((3,4)) #초기화 된 값 설정
"""
array([[3.56e-322, 0.00e+000, 0.00e+000, 0.00e+000],
       [0.00e+000, 0.00e+000, 0.00e+000, 0.00e+000],
       [0.00e+000, 0.00e+000, 0.00e+000, 0.00e+000]])"""

np.full((3,4),7) #7로만 이루어진 행렬을 만듬 
"""
array([[[7, 7],
        [7, 7],
        [7, 7],
        [7, 7]],

       [[7, 7],
        [7, 7],
        [7, 7],
        [7, 7]],

       [[7, 7],
        [7, 7],
        [7, 7],
        [7, 7]]])

"""
np.eye(5) #단위행렬생성 대각선이 1이고 나머지는 0인 행렬 행과 열이 같아야하므로 input은 숫자 하나 
"""
array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
"""
np.linspace(1,10,3) #파라미터 3 - 1과 10이 처음과 끝이고 전체가 3개가 되도록 균일하게 나눠라 
#결과 : array([ 1. ,  5.5, 10. ])
np.linspace(1,10,4)
#결과 : array([ 1.,  4.,  7., 10.]

#reshape 이용하기 
x = np.reshape(1,16)
print(x) #결과 : [ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]

x.shape # 결과 : (15,) - x의 성분이 나온다. 

x.reshape(3,5) #1행이었던것을 3행 5열로 바꿔라. 
"""
array([[ 1,  2,  3,  4,  5],
       [ 6,  7,  8,  9, 10],
       [11, 12, 13, 14, 15]])
"""
x = np.arange(1,17)
print(x)

x.shape

x.reshape(2,4,2) #4행 2열 2개 차원으로 바꿔라, 

"""
array([[[ 1,  2],
        [ 3,  4],
        [ 5,  6],
        [ 7,  8]],

       [[ 9, 10],
        [11, 12],
        [13, 14],
        [15, 16]]])
"""

#reshape 안의 숫자가 원래 행렬과의 갯수가 맞지 않으면 에러 
ValueError: cannot reshape array of size 16 into shape (2,4,3)
