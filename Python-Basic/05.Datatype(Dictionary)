"""
### 3. 딕셔너리 (Dictionary)
* 문법 기호/함수 : {key1:value1,key2:value2,key3:value3...} / 함수 : dict()
* key로 가질 수 있는 데이터 타입 : 문자, 숫자. 튜플(Tuple)
* value로 가질 수 있는 데이터 타입 : 문자, 숫자, 리스트, 딕셔너리
* 아이템 = key&value 하나의 쌍
* 종류
    - 아이템이 없는 딕셔너리
    * 1차원 딕셔너리
    - 다차원 딕셔너리
* 특징
    - key value 차이점
    - 인덱스 번호가 없음
"""

# 생성하기
# 딕셔너리 생성하기
# 문법기호 : {k1:v1,k2:v2,k3:v3...}
d1={1:10,2:20,3:30}
type(d1)

"""
### 2. 인덱싱
- 인덱싱 문법 기호
- 일차원 VS 다차원 인덱싱
- 딕셔너리 내장함수로 인덱싱
"""

d1={'a':[1,2,3],'b':100,'c':{'key1':['파인애플','포도','바나나'],'key2':(55,66)}}

# 1) 3출력하기
d1['a'][-1]

# 2 ) [파인애플,포도,바나나] 
d1['c']['key1']

# 3) 포도 출력하기
d1['c']['key1'][1]

# 4) 55출력하기
d1['c']['key2'][0]

"""
### 3. 아이템 추가하기 
- 인덱싱 방식으로 새로운 아이템 추가   # 딕셔너리에서 최상급으로 중요 
- 메소드 : update()
"""

d1={'a':1,'b':2,'c':3}

d1['d']=4
d1

# 기존에 존재하는 키값에 대해서 벨류를 할당하면 갱신된 값으로 저장 
d1['a']=10
d1

# 리스트로 update()사용하기

d2={'a':10,'b':2,'c':3,'d':4}

data=[('b',10),('c',40),('d',100),('e',300)]
d2.update(data)
d2
"""
### 4. 삭제하기

* 하나의 아이템 삭제하기

* 모든 아이템 삭제하기 : 객체는 삭제 되지 않는다.
"""
# 하나의 아이템 삭제하기 : del 키워드 + 딕셔너리 인덱싱 (단, get()은 삭제용도가 아님)
del d2['d']
d2

# 딕셔너리 비우기 : 딕셔너리.clear()
#del 은 변수 자체가 삭제되는 반면 .clear()는 변수는 남아있되 딕션리 내부만 비운다.
d2.clear()
d2
"""
### 5.딕셔너리 내장함수 & 관련 연산자 
- 딕셔너리타입.keys()
- 딕셔너리타입.values()
- 딕셔너리타입.items()
- in 연산자 
"""

# 딕셔너리가 가지고 있는 key만 리스트 형식으로 반환 : .keys()
d1 = {'name':'홍길동','age':18,'job':'학생'}
d1.keys()

# 딕셔너리가 가지고 있는 value만 리스트 형식으로 반환 : .value()
d1.values()

### <<연습문제>>
1. 아래와 같은 딕셔너리를 생성하고 해당 딕셔너리의 value중 최소값을 구하여 형식에 맞게 출력하세요 

dict_1={'A':9,'B':80,'C':70}

#조건1 생성한 딕셔너리에 'D':20 'E':100, 'F':10 아이템 3개를 추가하세요
add_dict=[('D',20),('E',100),('F',10)]
dict_1.update(add_dict)
dict_1

#조건2 key 'A'의 값을 9에서 90으로 변경하세요 
dict_1['A']=90
dict_1

#조건3 : 최소값 10을 가진 key는 F입니다. 로 포맷팅을 사용하여 출력하고 10을 포맷팅 값으로 사용하세요 
'최소값 %d을 가진 key는 F입니다.'%(dict_1['F'])

# 4. 최소 값은 딕셔너리에 속한 내장함수와 파이썬 내장함수를 모두 사용하여 구해보세요 
x=min(dict_1.values())
x

type(dict_1.values())

dict_1

list(dict_1.items())





