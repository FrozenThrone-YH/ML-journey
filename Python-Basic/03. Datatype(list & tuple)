"""
# 자료형 
 여러개의 아이템들을 저장하는 객체  =여러개의 값(데이터 타입)을 저장하는 그릇
 
1. 리스트 (list)
 ▶문법 기호 : [아이템1, 아이템2, 아이템3 ...]
 ▶용어 : 아이템 = 요소
 ▶아이템으로 가질 수 있는 데이터 타입 : 문자, 숫자, 리스트, 딕셔너리 ...
 ▶종류
     * 아이템이 없는 리스트 []
     * 1차원 리스트 [1,2,3,4]
     * 다차원 리스트 [[1,2],[3,4]] #2차원 이상의 데이터를 잘 다루게 된다.
 ▶특징
     * 인덱스 활용
     * 다차원 리스트의 구조에 대한 이해
"""

# 생성하기
# 빈 리스트 생성하기 = 아이템이 없는 리스트
# 문법기호 : []
# 함수 : list()

a = []
a2 = list()
print(type(a),type(a2))
print(a,a2)

# 모든 데이터타입을 아이템으로 가질 수 있다.
a3 = ['a',10,1.1,[1,23.1,'a'],True,{'a':1,'b':2}]
a3

# 2차원 배열은 내부 요소 하나만 타겟팅 하기 위해 인덱스 2개를 쓴다. 

a3[3][-1]

# 3차원 배열 예시
a4=[1,2,3,[1,2,3,[10,20]]]
a4[0]
a4[3]
a4[3][3]
a4[3][3][0]

"""
### 2. 인덱싱, 슬라이싱

리스트를 인덱스 번호로 접근하면 해당하는 위치의 값(아이템)을 가져온다.

※복습
    - 첫 번째 인덱스 번호는 ? = 0번 인덱스 = 첫 번째 아이템
    - 마지막 인덱스 번호는 ? = -1 = 마지막 아이템

### 인덱싱(indexing)

※정의 복습 : 특정 위치에 있는 하나의 아이템에 접근한다. = 하나의 값을 가져온다.
"""

# 리스트 생성하기
a = [1,2,3,4,5,6,7,8,9]

# 첫 번째 아이템 인덱스 번호 : 0 
# 인덱싱 문법 : 객체[인덱스번호]

a[0]

# 리스트의 6이라는 아이템 가져오기 
a[5]

# 리스트의 마지막 값 확인하기 : -1
a[-1] # = a[8]

# len()의 결과값

len(a)

"""
### 슬라이싱

- 정의복습 : 연속된 범위에 있는 하나 또는 하나 이상의 여러개 아이템에 접근한다.
- 문법기호 : 대상객체 (문자열, 리스트)[시작번호:끝번호:간격] => 끝번호는 포함하지 않는다!
"""

# 리스트의 첫 번째 아이템부터 3번째 아이템까지 확인하기
a[:3]
# 시작번호 : 0 
# 끝번호 2 => but 입력은 3 

a[0:3]

a[:1] #하나만 뽑아도 자료형이 list로 나온다. 

# 리스트의 4번째 아이템부터 마지막 아이템까지 확인하기 
# 시작번호 : 3 
# 끝번호 : 생략

a[3:]

### <<연습문제>>

다음의 4차원 리스트에서 아래 조건에 맞는 값을 출력해주세요

    a = [1,2,3,['a',[100,200,['강남','서울'],300],'b','c']]
    출력결과 = 강남 & 300 & c
    
a = [1,2,3,['a',[100,200,['강남','서울'],300],'b','c']]

print('출력결과 = %s & %s & %s' %(a[3][1][2][0],a[3][1][3],a[3][-1]))

# 강남 추출
a[3][1][2][0]

# 300 추출
a[3][1][-1]

# c 추출 
a[3][-1]

"""
### 3. 아이템 추가하기 : 연산자와 함수를 이용한 리스트 아이템 추가

1) 산술연산자 : +, * 
2) 리스트의 함수(메서드) : 리스트, append(), 리스트.extend(), 리스트.insert()

### 3-1 산술연산자

* 종류 : +,* 
* 특징 : 원본에 반영되지 않는다. 

"""    

a=[1,2,3]
b=[4,5,6]

a+b

print(a,b)

# 리스트 대상 곱하기 : *
b*3

b
"""
### 4. 리스트 타입의 함수 (method)
* 종류
    - 리스트.append(추가할 아이템) : 인자값을 통채로 리스트의 마지막 아이템으로 추가. 인자값은 1개만 받음 = 1개의 아이템만 추가 가능
    - 리스트.extend(추가할 아이템) : 인자값의 아이템을 뽑아서 리스트의 마지막 아이템으로 추가, 인자값은 1개만 받음, 단 여러 개의 아이템 추가 가능
    - 리스트.insert(추가할 아이템) : 위치를 지정해서 아이템을 삽입할수 있음, 통채로 아이템을 추가 
    - 특징 : 원본에 바로 적용이 됨 
   
* 참고 연산자 : in 연산자(결과값은 bool type)
"""

# 리스트 생성하기

a=[1,2,3]
a

# append()
# 문법 : 리스트, append(추가할 아이템)
a.append(4)
a           #초기화 하지 않고 한번 더 실행하면 [1,2,3,4,4] 가 된다. 

# 추가할 자료를 [5,6] 제공한다면?
a.append([5,6]) #3번째 인덱스에 [5,6] 리스트 통채로 들어간다. 
a

# extend()
# 문법 : 대상리스트.extend(리스트)
# append()와의 차이점 : 인자값으로 리스트만 받을 수 있다. 
# 리스트 길이만큼 인덱스가 연장된다. (append는 무조건 1만큼만 연장됨)

a.extend([7,8,9])
a

# insert()
# 문법 : 대상리스트, insert(인덱스번호, 추가할 아이템)
# 다른 함수와의 차이점 : 아이템 추가가 마지막 인덱스번호가 아닌 지정한 인덱스로 
# append와의 유사점 : 하나의 인덱스에 다 때려박음

a.insert(0,100)
a

a.insert(0,[99,98])
a

# in 키워드는 특정 요소가 리스트 내부에 있는지 없는지를 물어봅니다.
# 값 in 리스트
# 100이 a리스트에 있습니까? 100 in a 
99 in a[0]

99 in a #a[0] 은 [99,98] 있기때문에 들어있다고 하는데, 1차원에서 물어보면 없다고 뜬다. 

# not in 키워드는 특정 요소가 리스트 내부에 없는지 있는지 물어봅니다.
# 값 not in 리스트
# 50이 a 리스트에 없습니까? -> 50 not in a 
50 not in a

# 1) 빈 리스트 생성
# 2) 1번 리스트에 숫자 1,2,3을 아이템으로 추가 
# 3) 2번 리스트의 3번째 위치에 문자 100을 아이템으로 추가 
# 4) 3번 리스트의 마지막에 문자 A,B를 아이템으로 가진 리스트를 아이템으로 추가 
# 5) 4번 리스트의 아이템을 2번 반복해서 가지는 리스트를 출력 

l_1 = []
l_1.extend([1,2,3])
# for i in range(1,4):
#    l_1.append(i)
# l_1 이런 반복문 형태를 많이 쓰게 된다. 
l_1.insert(2,'100')
l_1.append(['A','B'])
l_1*2

### 5. 아이템 수정하기

# 인덱싱, 슬라이싱을 이용해서 아이템을 수정할 수 있다 / 인덱싱-insert, 슬라이싱 - extend

# 리스트 생성하기
a = [1,2,3,4]

# 하나의 아이템 수정하기
# 0번 인덱스에 있는 값을 [10,20]으로 수정하기
# [[10,20],2,3,4]

a[0]=[10,20] # insert처럼 들어간다. 
a

a[0]=10
a

# 연속된 범위에 있는 여러개의 아이템 수정하기
# 0번 인덱스만 선택 <= 슬라이싱

a2 = [1,2,3,4]
a2[0:1] = [10,20] # extend처럼 들어간다. 
a2

"""
### <<연습문제>>

조건1) '사과'를 'apple'로 수정

조건2) 99,3을 9,33으로 수정

조건3) 73을 [73,74]로 수정
"""

a=[10,99,3,'사과',73,'바나나']
a[3]='apple'
a[1:3]=[9,33]
a[4]=[73,74]
a
"""
### 6. 아이템 삭제하기

* 슬라이싱

* del 키워드 + 인덱싱/슬라이싱

* remove() 메서드 : 값을 기준으로 삭제 

* pop()
    - 인자값에 아무것도 입력하지 않거나 -1을 입력하면 마지막 인덱스를 삭제
    - 특정 인덱스를 지정하여 삭제 
 """
 
 # 리스트 생성하기
a1 = [10,20,30,40,50]
a2 = [10,20,30,40,50]
# 하나의 아이템 삭제하기 1 : 슬라이싱 = 빈 리스트
# 0번 인덱스 값 삭제시

a1[0:1]=[]
a1
# 만약 인덱싱을 쓴다면
a2[0] = []
a2
# 하나의 아이템 삭제하기 2 => del + 인덱싱

del a1[-1]
a1
# 만약 인덱싱 없이 del 키워드를 쓴다면
del a2  #a2라는 자료 자체가 삭제 된다. 
a2
# 하나의 아이템 삭제하기 3 - remove() 메서드
# 문법 : 리스트.remove(삭제할자료(인덱스 아님!!))

a = [1,2,3,3,3,4,5]
a
#5라는 값을 삭제

a.remove(5) #인덱싱이 아니라 5라는 자료 자체를 삭제 
a
# 중복된 아이템이 존재하면 가장 앞서는 인덱스 자료 하나만 삭제
a.remove(3)
a
# del 키워드는 단일 자료뿐만 아니라 연속된 범위(슬라이싱) 자료 삭제도 가능하다.a

del a[2:]
a
# 마지막에 위치한 아이템 값을 '확인시켜주고' 삭제하기 = pop()함수

a.append(6)
b=a.pop() #인덱스 번호 미기입시 마지막 인덱스 자료 삭제(6삭제)
#내가 뭘 삭제하는지 모르면서 삭제하는 경우가 생길수도 있다. 
b
a
a.pop(0)
a
"""
### 7. 아이템 정렬하기

* 함수
    - sort() : 기본동작 = 오름차순 정렬(작은값이 먼저오고 큰값이 나중에)
    - reverse() : 기존 리스트의 처음과 마지막 순서를 뒤집어서 나열  ※인덱스순서를 반대로 한다. .
    
    - 문자도 오름차순 정렬이된다. 아스키코드 순서대로 
"""

a=[10,-30,57,-33,71,1,34,-2]
a
# 값을 오름차순으로 정렬 : sort() 기본동작 / sort(reverse=False)
# 원본 리스트 변경

a.sort()
a
# 값을 오름차순이 아닌 내림차순으로 정렬하는 경우 : .sort(reverse=Ture)
a.sort(reverse=True)
a
# 값을 인덱스기준으로 반대로 뒤집기 : reverse()
b = [10, 71, 32, 46,5 ,96]
b
b.reverse()
b
c = ['a','b','C','D','e']
c
c.sort()
c
"""
### 8. 아이템 개수 세기
* 함수
    - 리스트.count(값) : 값이 리스트에 몇 개 있는지 개수를 변환 => 특정 아이템의 개수를 반환
    - len() : 파이썬 내장함수, 인자값으로 전달 받은 객체의 길이 => 전체 아이템의 개수를 반환 
"""
a = [1,2,3,3,3,4,5,6]
# 특정 아이템의 개수 : count()
a.count(1)
a.count(3)
a.count(10)
# 
len(a)
"""
### 9. 리스트 복사하기

* 할당 기호

* copy() 메세드

* list()

* 슬라이싱  

- 설명 : b = a로 할당하고 a를 바꿨을때 왜 b도 바뀌는가?! (모든 언어 공통점) 

    * 변수는 2종류가 있다. 기본형 변수 / 참조형 변수 
    * 변수 1개에 값이 1개가 매칭되는 케이스 ex) int, float
      a =1 , a=2 a에 담기는 수는 1개 - 2를 넣는 순간 1이 사라진다.
    * 변수 1개에 자료 2개가 동시에 들어갈 수 도 있는 자료형 ex) list
    * 모든 프로그램은 변수 한개에 자료 한개 넣도록 프로그래밍 되어 있다?
    * 메모리 - 시스템(코드)영역 / 파이썬 인터프리터 - *번역기* => 기계어로 번역한다. 
            시스템코드영역은 파이썬 코드를 기계어로 바꿔주는 영역 
            시스템코드영역은 사람의 통제가 안되는 영역이다. 필요한 메모리 할당은 바꾸지 못한다.
            통제 가능 영역은 힙 데이터와 스택 영역 
            a=5 , a=[1,2,3,4,5] 리스트는 스택을 차지하는 영역이 큼 
            따라서 스택에 저장되는 값은 하나씩만 가지고 있자 - 참조형변수는 표지판만 박아둔다.
            표지판 - 힙데이터 어디에 데이터가 있데요
            힙데이터에 실제로 그 데이터가 있다. 
            b = a를 하면 b는 a의 표지판을 가져온다. 이런 유형은 얕은 복사 쉘로우 카피 (shallow copy)
            표지판을 복사해 오니까 동기화가 된다. 
"""

# 1, 할당기호(=)로 복사하기
a = [1,2,3,4,5]
b=a
print(a,b)
# a의 0번째 요소 10으로 교환
a[0] = 10
print(a,b)
id(a)
id(b)
a1 = [1,2,3,4,5]
b1 = [1,2,3,4,5]
print(id(a1),id(b1))
# 2. copy() 메서드로 복사하기 

c=a.copy() #a의 주소로 들어갔을때 나오는 자료를 복사하는 메서드 
c
id(c)
# 파이썬에서는 id(자료)를 이용해 저장된 번지수 조회가 가능하다. 
print(id(a),id(b))
print(id(a),id(c))
a[2]=20
print(a,b,c) #c는 변경되지 않는다. 
# 3. list()로 복사하기 
# list(자표)를 넣으면 그 자료를 리스트화 해준다. 
d = list(c)
d
#깊은 복사 여부 확인 
print(id(c),id(d))
# 4.슬라이싱으로 복사하기 
e = d[:]
print(id(d),id(e)) #이것도 깊은 복사 / 데이터를 뽑아내야 깊은 복사 
"""
### <<연습문제>>

1. a리스트를 이용하여 다음과 같은 문자열을 출력하시오.

  a=['Life','is','too','short','you','need','python']
"""

